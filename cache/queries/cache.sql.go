// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: cache.sql

package queries

import (
	"context"
	"time"
)

const countEntries = `-- name: CountEntries :one
SELECT COUNT(*)
FROM cache
`

func (q *Queries) CountEntries(ctx context.Context) (int64, error) {
	row := q.queryRow(ctx, q.countEntriesStmt, countEntries)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createCacheDatabase = `-- name: CreateCacheDatabase :exec
CREATE TABLE IF NOT EXISTS cache (
    key TEXT PRIMARY KEY,
    value BLOB,
    expires_at TIMESTAMP NOT NULL,
    last_accessed_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
)
`

func (q *Queries) CreateCacheDatabase(ctx context.Context) error {
	_, err := q.exec(ctx, q.createCacheDatabaseStmt, createCacheDatabase)
	return err
}

const deleteExpiredCache = `-- name: DeleteExpiredCache :exec
DELETE FROM cache
WHERE expires_at <= ?
`

func (q *Queries) DeleteExpiredCache(ctx context.Context, expiresAt time.Time) error {
	_, err := q.exec(ctx, q.deleteExpiredCacheStmt, deleteExpiredCache, expiresAt)
	return err
}

const deleteKey = `-- name: DeleteKey :exec
DELETE FROM cache
WHERE key = ?
`

func (q *Queries) DeleteKey(ctx context.Context, key string) error {
	_, err := q.exec(ctx, q.deleteKeyStmt, deleteKey, key)
	return err
}

const deleteKeysByLimit = `-- name: DeleteKeysByLimit :exec
DELETE FROM cache
WHERE key IN (
    SELECT key
    FROM cache
    ORDER BY last_accessed_at ASC
    LIMIT ?
)
`

func (q *Queries) DeleteKeysByLimit(ctx context.Context, limit int64) error {
	_, err := q.exec(ctx, q.deleteKeysByLimitStmt, deleteKeysByLimit, limit)
	return err
}

const getValue = `-- name: GetValue :one
SELECT value
FROM cache
WHERE key = ? AND expires_at > ?
`

type GetValueParams struct {
	Key       string    `json:"key"`
	ExpiresAt time.Time `json:"expires_at"`
}

func (q *Queries) GetValue(ctx context.Context, arg GetValueParams) ([]byte, error) {
	row := q.queryRow(ctx, q.getValueStmt, getValue, arg.Key, arg.ExpiresAt)
	var value []byte
	err := row.Scan(&value)
	return value, err
}

const selectKeysToDelete = `-- name: SelectKeysToDelete :many
SELECT key
FROM cache
ORDER BY last_accessed_at ASC
LIMIT ?
`

func (q *Queries) SelectKeysToDelete(ctx context.Context, limit int64) ([]string, error) {
	rows, err := q.query(ctx, q.selectKeysToDeleteStmt, selectKeysToDelete, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var key string
		if err := rows.Scan(&key); err != nil {
			return nil, err
		}
		items = append(items, key)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateLastAccessedAt = `-- name: UpdateLastAccessedAt :exec
UPDATE cache
SET last_accessed_at = ?
WHERE key = ?
`

type UpdateLastAccessedAtParams struct {
	LastAccessedAt time.Time `json:"last_accessed_at"`
	Key            string    `json:"key"`
}

func (q *Queries) UpdateLastAccessedAt(ctx context.Context, arg UpdateLastAccessedAtParams) error {
	_, err := q.exec(ctx, q.updateLastAccessedAtStmt, updateLastAccessedAt, arg.LastAccessedAt, arg.Key)
	return err
}

const upsertCache = `-- name: UpsertCache :exec
INSERT INTO cache (key, value, expires_at, last_accessed_at)
VALUES (?, ?, ?, ?)
ON CONFLICT (key) DO UPDATE
SET value = excluded.value,
    expires_at = excluded.expires_at,
    last_accessed_at = excluded.last_accessed_at
`

type UpsertCacheParams struct {
	Key            string    `json:"key"`
	Value          []byte    `json:"value"`
	ExpiresAt      time.Time `json:"expires_at"`
	LastAccessedAt time.Time `json:"last_accessed_at"`
}

func (q *Queries) UpsertCache(ctx context.Context, arg UpsertCacheParams) error {
	_, err := q.exec(ctx, q.upsertCacheStmt, upsertCache,
		arg.Key,
		arg.Value,
		arg.ExpiresAt,
		arg.LastAccessedAt,
	)
	return err
}
